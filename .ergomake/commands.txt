cd .ergomake
docker compose up --build -d 

# Start cluster and enable ingress controller
minikube start
minikube addons enable ingress

# Build images inside Minikube's Docker
eval "$(minikube docker-env)"
docker build -t backend:latest ./backend
docker build -t frontend:latest ./frontend

# Apply manifests
kubectl apply -f .ergomake/k8s-manifests.yaml

# Get the IP and open the app
minikube ip
# Visit: http://<minikube-ip>/

kubectl get pods -w


Option A — minikube service (simple)
```bash
minikube service frontend --url
# Open the printed URL (e.g., http://127.0.0.1:46143) and keep this terminal open
```

Option B — Port-forward the Ingress controller
```bash
kubectl -n ingress-nginx port-forward svc/ingress-nginx-controller 8080:80
# Then open http://localhost:8080
# Test API: curl -s http://localhost:8080/api/tags
```

Option C — LoadBalancer + tunnel (persistent)
```bash
kubectl -n ingress-nginx patch svc ingress-nginx-controller -p '{"spec":{"type":"LoadBalancer"}}'
sudo -E minikube tunnel
kubectl -n ingress-nginx get svc ingress-nginx-controller  # note EXTERNAL-IP
# Open http://<EXTERNAL-IP>/
```

Quick sanity checks:
```bash
kubectl get ingress
kubectl get ep frontend backend


If any update: 

# Use Minikube’s Docker
eval "$(minikube docker-env)"

# Rebuild image with prom-client included
docker build -t backend:latest ./backend

# Restart the deployment to pick up the new image
kubectl rollout restart deploy/backend
kubectl rollout status deploy/backend














# Pull images locally (host)
docker pull docker.io/grafana/grafana:12.2.0
docker pull quay.io/prometheus/prometheus:v3.7.1
docker pull quay.io/prometheus-operator/prometheus-config-reloader:v0.86.1
docker pull quay.io/prometheus-operator/prometheus-operator:v0.86.1
docker pull quay.io/prometheus/node-exporter:v1.9.1
docker pull registry.k8s.io/kube-state-metrics/kube-state-metrics:v2.17.0
docker pull quay.io/kiwigrid/k8s-sidecar:1.30.10
docker pull quay.io/prometheus/alertmanager:v0.28.1

# Load them into the Minikube node
minikube image load docker.io/grafana/grafana:12.2.0
minikube image load quay.io/prometheus/prometheus:v3.7.1
minikube image load quay.io/prometheus-operator/prometheus-config-reloader:v0.86.1
minikube image load quay.io/prometheus-operator/prometheus-operator:v0.86.1
minikube image load quay.io/prometheus/node-exporter:v1.9.1
minikube image load registry.k8s.io/kube-state-metrics/kube-state-metrics:v2.17.0
minikube image load quay.io/kiwigrid/k8s-sidecar:1.30.10
minikube image load quay.io/prometheus/alertmanager:v0.28.1

# Bounce the stuck pods to pick up local images
kubectl -n monitoring delete pod -l app.kubernetes.io/name=grafana
kubectl -n monitoring delete pod -l app.kubernetes.io/name=prometheus
kubectl -n monitoring delete pod -l app.kubernetes.io/name=alertmanager

# Watch until Ready
kubectl -n monitoring get pods -w









# Re-apply k8s after edits
kubectl apply -f .ergomake/k8s-manifests.yaml
kubectl apply -f .ergomake/monitoring/servicemonitors.yaml

# Install kube-prometheus-stack (Prometheus+Grafana)
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo update
helm upgrade --install kps prometheus-community/kube-prometheus-stack \
  --namespace monitoring --create-namespace


kubectl -n monitoring get pods
kubectl -n monitoring get svc
# Prometheus UI
kubectl -n monitoring port-forward svc/kps-kube-prometheus-stack-prometheus 9090:9090
# Grafana UI (default admin/prom-operator)
kubectl -n monitoring port-forward svc/kps-grafana 3000:80


kubectl -n monitoring get secret kps-grafana -o jsonpath='{.data.admin-user}' | base64 -d; echo
kubectl -n monitoring get secret kps-grafana -o jsonpath='{.data.admin-password}' | base64 -d; echo